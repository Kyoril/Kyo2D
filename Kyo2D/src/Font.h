
#pragma once

#include <memory>
#include <map>
#include "File.h"
#include "FontGlyph.h"
#include "FontImageset.h"
#include <ft2build.h>
#include FT_FREETYPE_H

namespace Kyo2D
{
	/// Base class for a texture.
	class Font : public std::enable_shared_from_this<Font>
	{
		/// Contains infos about font glyphs
		typedef std::map<std::uint32_t, FontGlyph> GlyphMap;

	public:

		/// Default constructor.
		Font();
		/// Destructor.
		virtual ~Font();

		/// Initializes this font by loading it from memory.
		virtual bool Initialize(const void *data, size_t dataSize, float pointSize, float outline = 0.0f);
		/// Initializes this font by loading it from a file.
		virtual bool Initialize(const std::wstring &filename, float pointSize, float outline = 0.0f);

	private:

		/// A horizontal pixel span generated by the FreeType renderer.
		struct Span
		{
			Span() { }
			Span(int _x, int _y, int _width, int _coverage)
				: x(_x), y(_y), width(_width), coverage(_coverage) { }

			int x, y, width, coverage;
		};

		typedef std::vector<Span> Spans;

		union Pixel32
		{
			Pixel32()
				: integer(0)
			{
			}
			Pixel32(std::uint8_t bi, std::uint8_t gi, std::uint8_t ri, std::uint8_t ai = 255)
			{
				b = bi;
				g = gi;
				r = ri;
				a = ai;
			}

			std::uint32_t integer;
			struct
			{
				std::uint8_t b, g, r, a;
			};
		};

	private:

		/// Initializes the font after m_fileData has been filled.
		bool initializeInternal();
		/// Calculates the required texture size to contain all glyphs from start to end.
		/// @param start The first glyph to contain.
		/// @param end The last glyph to contain.
		/// @return Texture size in pixels for one edge (these textures are squared)
		std::uint32_t getTextureSize(GlyphMap::const_iterator start, GlyphMap::const_iterator end) const;
		/// Sets the maximal glyph index. This reserves the respective number 
		/// of bits in the m_glyphPageLoaded array.
		void setMaxCodepoint(std::uint32_t codepoint);
		/// Prepares a certain range of glyphs to be ready for displaying.
		void rasterize(std::uint32_t startCodepoint, std::uint32_t endCodepoint);
		/// Draws the currently rasterized glyph to the given buffer.
		void drawSpansToBuffer(std::uint32_t* buffer, std::uint32_t textureSize, const Spans& spans) const;

	private:

		static void rasterCallback(const int y, const int count, const FT_Span * const spans, void * const user);
		static void renderSpans(FT_Library &library, FT_Outline * const outline, Font::Spans *spans);

	public:

		/// Calculates the width of a given text in pixels.
		/// @param text The text whose width will be calculated.
		/// @param scale Scaling parameter which is multiplied with the actual width value.
		/// @return Width of the given text in pixels.
		float getTextWidth(const std::wstring& text, float scale = 1.0f);
		/// Returns a pointer to the glyph data structure for the given codepoint, or nullptr
		/// if the codepoint does not have a glyph defined.
		/// @param codepoint The codepoint to return the glyph data structure for.
		/// @param nullptr if the codepoint isn't available in the font.
		const FontGlyph* getGlyphData(std::uint32_t codepoint);
		/// Draws text at the given position using this font.
		void drawText(const std::wstring& text, const Vector2& position, float scale = 1.0f);

	public:

		/// Gets the height between two lines of text.
		/// @param scale Scaling parameter which is multiplied with the actual height value.
		/// @return Height between two lines of text in pixels.
		inline float getLineSpacing(float scale = 1.0f) const { return m_height * scale; }
		/// Gets the height of a text line.
		/// @param scale Scaling parameter which is multiplied with the actual height value.
		/// @return Height of a text line in pixels.
		inline float getHeight(float scale = 1.0f) const { return (m_ascender - m_descender) * scale; }
		/// Gets the number of pixels from the top of the highest glyph to the baseline.
		/// @param scale Scaling parameter which is multiplied with the actual height value.
		/// @return Number of pixels from the top of the highest glyph to the baseline.
		inline float getBaseline(float scale = 1.0f) const { return m_ascender * scale; }

	private:

		/// Custom deleter for a smart pointer of type FT_FaceRec_* alias FT_Face
		struct FT_FaceRec_Deleter
		{
			/// Execution operator performs the delete process
			virtual void operator()(FT_FaceRec_* x)
			{
				FT_Done_Face(x);
			}
		};

		/// Font pointer typedef with auto delete mechanics
		typedef std::unique_ptr<FT_FaceRec_, FT_FaceRec_Deleter> FT_FacePtr;

	private:

		/// The file data has to keep alive while working with FT_Face or else it
		/// the application will crash.
		FileData m_fileData;
		/// The font face.
		FT_FacePtr m_fontFace;
		/// Size of this font in points
		float m_pointSize;
		/// The maximum amount of pixels above the baseline
		float m_ascender;
		/// The maximum amount of pixels below the baseline
		float m_descender;
		/// (Ascender - Descender) + Linegap
		float m_height;
		/// The outline width (set to 0.0 if no outline should be used).
		float m_outlineWidth;
		/// Map of font glyphs.
		GlyphMap m_glyphMap;
		/// Maximal glyph index.
		std::uint32_t m_maxCodepoint;
		/// This array holds information about loaded glyph pages. A glyph page
		/// is a set of 256 codepoints, starting at 256-multiples.
		std::vector<uint32_t> m_glyphPageLoaded;
		/// Contains all loaded font imagesets.
		std::list<FontImageset> m_imageSets;
	};
}
